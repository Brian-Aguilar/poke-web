{"version":3,"sources":["../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/crossfader.js","../node_modules/framer-motion/dist/es/animation/animate.js","../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/stack.js","../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/index.js","../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/rotate.js","../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.js","../node_modules/framer-motion/dist/es/components/AnimatePresence/index.js","../node_modules/framer-motion/dist/es/utils/use-force-update.js"],"names":["createCrossfader","progress","motionValue","options","lead","undefined","follow","crossfadeOpacity","preserveFollowOpacity","leadState","followState","isActive","finalCrossfadeFrame","prevUpdate","startCrossfadeAnimation","target","transition","hasUpdated","onUpdate","scheduleRender","onComplete","getFrameData","timestamp","from","to","value","isMotionValue","startAnimation","stop","animate","__assign","set","sync","read","updateCrossfade","_a","_b","latestLeadValues","getLatestValues","Object","assign","latestFollowValues","prevValues","p","get","leadTargetOpacity","opacity","followTargetOpacity","mix","easeCrossfadeIn","easeCrossfadeOut","hasFollowElement","i","numBorders","borderLabel","borders","followRadius","getRadius","leadRadius","radius","rotate","backgroundColor","mixColor","mixValues","Boolean","fromLead","toLead","reset","getCrossfadeState","element","setOptions","newOptions","compress","circOut","linear","min","max","easing","length","values","radiusName","borderRadius","layoutStack","prevViewportBox","prevDragCursor","stack","Set","state","leadIsExiting","prevState","crossfader","needsCrossfadeAnimation","add","setCrossfader","remove","delete","getLead","updateSnapshot","dragControls","elementDragControls","isDragging","cursorProgress","clearSnapshot","updateLeadAndFollow","order","Array","presence","Presence","Exiting","isPresenceRoot","child","shouldCrossfade","pointTo","setVisibility","config","Entering","originBox","targetBox","getLayoutState","layout","getFollowLayout","getDefaultTransition","notifyLayoutReady","AnimateSharedLayout","_super","_this","apply","this","arguments","children","stacks","Map","hasMounted","updateScheduled","renderScheduled","syncContext","createBatcher","syncUpdate","force","scheduleUpdate","forceUpdate","register","addChild","removeChild","__extends","prototype","componentDidMount","componentDidUpdate","startLayoutAnimation","shouldComponentUpdate","type","props","forEach","isPresent","Present","updateStacks","handler","measureLayout","updateLayoutMeasurement","layoutReady","getLayoutId","getStack","parent","context","visualElement","flush","hasRotate","resetValues","transformAxes","key","hasValue","getStaticValue","setStaticValue","syncRender","resetRotate","snapshotViewportBox","addToStack","removeFromStack","id","has","render","React","SharedLayoutContext","Provider","contextType","MotionContext","presenceId","getPresenceId","PresenceChild","initial","onExitComplete","custom","presenceAffectsLayout","presenceChildren","useConstant","newChildrenMap","useMemo","childId","allComplete","isComplete","_","size","PresenceContext","getChildKey","AnimatePresence","exitBeforeEnter","_c","forceRender","unloadingRef","useRef","__read","useState","forcedRenderCount","setForcedRenderCount","useUnmountEffect","current","useCallback","useForceUpdate","layoutContext","useContext","isSharedLayout","isInitialRender","filteredChildren","filtered","Children","isValidElement","push","onlyElements","presentChildren","allChildren","exiting","updateChildLookup","map","childrenToRender","__spreadArray","presentKeys","targetKeys","numPresent","indexOf","insertionIndex","splice","removeIndex","findIndex","presentChild","cloneElement"],"mappings":"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","file":"static/js/6.d628fedb.chunk.js","sourcesContent":["import { __assign } from 'tslib';\nimport sync, { getFrameData } from 'framesync';\nimport { mix, progress, linear, mixColor, circOut } from 'popmotion';\nimport { animate } from '../../../animation/animate.js';\nimport { motionValue } from '../../../value/index.js';\n\nfunction createCrossfader() {\n    /**\n     * The current state of the crossfade as a value between 0 and 1\n     */\n    var progress = motionValue(1);\n    var options = {\n        lead: undefined,\n        follow: undefined,\n        crossfadeOpacity: false,\n        preserveFollowOpacity: false,\n    };\n    var leadState = {};\n    var followState = {};\n    /**\n     *\n     */\n    var isActive = false;\n    /**\n     *\n     */\n    var finalCrossfadeFrame = null;\n    /**\n     * Framestamp of the last frame we updated values at.\n     */\n    var prevUpdate = 0;\n    function startCrossfadeAnimation(target, transition) {\n        var lead = options.lead, follow = options.follow;\n        isActive = true;\n        finalCrossfadeFrame = null;\n        var hasUpdated = false;\n        var onUpdate = function () {\n            hasUpdated = true;\n            lead && lead.scheduleRender();\n            follow && follow.scheduleRender();\n        };\n        var onComplete = function () {\n            isActive = false;\n            /**\n             * If the crossfade animation is no longer active, flag a frame\n             * that we're still allowed to crossfade\n             */\n            finalCrossfadeFrame = getFrameData().timestamp;\n        };\n        return animate(progress, target, __assign(__assign({}, transition), { onUpdate: onUpdate, onComplete: function () {\n                if (!hasUpdated) {\n                    progress.set(1);\n                    /**\n                     * If we never ran an update, for instance if this was an instant transition, fire a\n                     * simulated final frame to ensure the crossfade gets applied correctly.\n                     */\n                    sync.read(onComplete);\n                }\n                else {\n                    onComplete();\n                }\n                onUpdate();\n            } }));\n    }\n    function updateCrossfade() {\n        var _a, _b;\n        /**\n         * We only want to compute the crossfade once per frame, so we\n         * compare the previous update framestamp with the current frame\n         * and early return if they're the same.\n         */\n        var timestamp = getFrameData().timestamp;\n        var lead = options.lead, follow = options.follow;\n        if (timestamp === prevUpdate || !lead)\n            return;\n        prevUpdate = timestamp;\n        /**\n         * Merge each component's latest values into our crossfaded state\n         * before crossfading.\n         */\n        var latestLeadValues = lead.getLatestValues();\n        Object.assign(leadState, latestLeadValues);\n        var latestFollowValues = follow\n            ? follow.getLatestValues()\n            : options.prevValues;\n        Object.assign(followState, latestFollowValues);\n        var p = progress.get();\n        /**\n         * Crossfade the opacity between the two components. This will result\n         * in a different opacity for each component.\n         */\n        var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\n        var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\n        if (options.crossfadeOpacity && follow) {\n            leadState.opacity = mix(0, leadTargetOpacity, easeCrossfadeIn(p));\n            followState.opacity = options.preserveFollowOpacity\n                ? followTargetOpacity\n                : mix(followTargetOpacity, 0, easeCrossfadeOut(p));\n        }\n        else if (!follow) {\n            leadState.opacity = mix(followTargetOpacity, leadTargetOpacity, p);\n        }\n        mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\n    }\n    return {\n        isActive: function () {\n            return leadState &&\n                (isActive || getFrameData().timestamp === finalCrossfadeFrame);\n        },\n        fromLead: function (transition) {\n            return startCrossfadeAnimation(0, transition);\n        },\n        toLead: function (transition) {\n            progress.set(options.follow ? 1 - progress.get() : 0);\n            return startCrossfadeAnimation(1, transition);\n        },\n        reset: function () { return progress.set(1); },\n        stop: function () { return progress.stop(); },\n        getCrossfadeState: function (element) {\n            updateCrossfade();\n            if (element === options.lead) {\n                return leadState;\n            }\n            else if (element === options.follow) {\n                return followState;\n            }\n        },\n        setOptions: function (newOptions) {\n            options = newOptions;\n            leadState = {};\n            followState = {};\n        },\n        getLatestValues: function () {\n            return leadState;\n        },\n    };\n}\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\nfunction compress(min, max, easing) {\n    return function (p) {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\n    /**\n     * Mix border radius\n     */\n    for (var i = 0; i < numBorders; i++) {\n        var borderLabel = \"border\" + borders[i] + \"Radius\";\n        var followRadius = getRadius(latestFollowValues, borderLabel);\n        var leadRadius = getRadius(latestLeadValues, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        /**\n         * Currently we're only crossfading between numerical border radius.\n         * It would be possible to crossfade between percentages for a little\n         * extra bundle size.\n         */\n        if (typeof followRadius === \"number\" &&\n            typeof leadRadius === \"number\") {\n            var radius = mix(followRadius, leadRadius, p);\n            leadState[borderLabel] = followState[borderLabel] = radius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (latestFollowValues.rotate || latestLeadValues.rotate) {\n        var rotate = mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\n        leadState.rotate = followState.rotate = rotate;\n    }\n    /**\n     * We only want to mix the background color if there's a follow element\n     * that we're not crossfading opacity between. For instance with switch\n     * AnimateSharedLayout animations, this helps the illusion of a continuous\n     * element being animated but also cuts down on the number of paints triggered\n     * for elements where opacity is doing that work for us.\n     */\n    if (!hasFollowElement &&\n        latestLeadValues.backgroundColor &&\n        latestFollowValues.backgroundColor) {\n        /**\n         * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n         * We could probably create a mixer that runs at the start of the animation but\n         * the idea behind the crossfader is that it runs dynamically between two potentially\n         * changing targets (ie opacity or borderRadius may be animating independently via variants)\n         */\n        leadState.backgroundColor = followState.backgroundColor = mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\n    }\n}\nfunction getRadius(values, radiusName) {\n    var _a;\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n\nexport { createCrossfader };\n","import { motionValue } from '../value/index.js';\nimport { isMotionValue } from '../value/utils/is-motion-value.js';\nimport { startAnimation } from './utils/transitions.js';\n\n/**\n * Animate a single value or a `MotionValue`.\n *\n * The first argument is either a `MotionValue` to animate, or an initial animation value.\n *\n * The second is either a value to animate to, or an array of keyframes to animate through.\n *\n * The third argument can be either tween or spring options, and optional lifecycle methods: `onUpdate`, `onPlay`, `onComplete`, `onRepeat` and `onStop`.\n *\n * Returns `AnimationPlaybackControls`, currently just a `stop` method.\n *\n * ```javascript\n * const x = useMotionValue(0)\n *\n * useEffect(() => {\n *   const controls = animate(x, 100, {\n *     type: \"spring\",\n *     stiffness: 2000,\n *     onComplete: v => {}\n *   })\n *\n *   return controls.stop\n * })\n * ```\n *\n * @public\n */\nfunction animate(from, to, transition) {\n    if (transition === void 0) { transition = {}; }\n    var value = isMotionValue(from) ? from : motionValue(from);\n    startAnimation(\"\", value, to, transition);\n    return {\n        stop: function () { return value.stop(); },\n    };\n}\n\nexport { animate };\n","import { __assign } from 'tslib';\nimport { Presence } from '../types.js';\nimport { elementDragControls } from '../../../gestures/drag/VisualElementDragControls.js';\nimport { createCrossfader } from './crossfader.js';\n\nfunction layoutStack() {\n    var stack = new Set();\n    var state = { leadIsExiting: false };\n    var prevState = __assign({}, state);\n    var prevValues;\n    var prevViewportBox;\n    var prevDragCursor;\n    var crossfader = createCrossfader();\n    var needsCrossfadeAnimation = false;\n    function getFollowViewportBox() {\n        return state.follow ? state.follow.prevViewportBox : prevViewportBox;\n    }\n    function getFollowLayout() {\n        var _a;\n        return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;\n    }\n    return {\n        add: function (element) {\n            element.setCrossfader(crossfader);\n            stack.add(element);\n            /**\n             * Hydrate new element with previous drag position if we have one\n             */\n            if (prevDragCursor)\n                element.prevDragCursor = prevDragCursor;\n            if (!state.lead)\n                state.lead = element;\n        },\n        remove: function (element) {\n            stack.delete(element);\n        },\n        getLead: function () { return state.lead; },\n        updateSnapshot: function () {\n            if (!state.lead)\n                return;\n            prevValues = crossfader.isActive()\n                ? crossfader.getLatestValues()\n                : state.lead.getLatestValues();\n            prevViewportBox = state.lead.prevViewportBox;\n            var dragControls = elementDragControls.get(state.lead);\n            if (dragControls && dragControls.isDragging) {\n                prevDragCursor = dragControls.cursorProgress;\n            }\n        },\n        clearSnapshot: function () {\n            prevDragCursor = prevViewportBox = undefined;\n        },\n        updateLeadAndFollow: function () {\n            var _a;\n            prevState = __assign({}, state);\n            var lead;\n            var follow;\n            var order = Array.from(stack);\n            for (var i = order.length; i--; i >= 0) {\n                var element = order[i];\n                if (lead)\n                    follow !== null && follow !== void 0 ? follow : (follow = element);\n                lead !== null && lead !== void 0 ? lead : (lead = element);\n                if (lead && follow)\n                    break;\n            }\n            state.lead = lead;\n            state.follow = follow;\n            state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;\n            crossfader.setOptions({\n                lead: lead,\n                follow: follow,\n                prevValues: prevValues,\n                crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot),\n            });\n            if (state.follow &&\n                (prevState.lead !== state.lead ||\n                    prevState.leadIsExiting !== state.leadIsExiting)) {\n                needsCrossfadeAnimation = true;\n            }\n        },\n        animate: function (child, shouldCrossfade) {\n            if (shouldCrossfade === void 0) { shouldCrossfade = false; }\n            if (child === state.lead) {\n                if (shouldCrossfade) {\n                    /**\n                     * Point a lead to itself in case it was previously pointing\n                     * to a different visual element\n                     */\n                    child.pointTo(state.lead);\n                }\n                else {\n                    child.setVisibility(true);\n                }\n                var config = {};\n                if (child.presence === Presence.Entering) {\n                    config.originBox = getFollowViewportBox();\n                }\n                else if (child.presence === Presence.Exiting) {\n                    config.targetBox = getFollowLayout();\n                }\n                if (needsCrossfadeAnimation) {\n                    needsCrossfadeAnimation = false;\n                    var transition = child.getDefaultTransition();\n                    child.presence === Presence.Entering\n                        ? crossfader.toLead(transition)\n                        : crossfader.fromLead(transition);\n                }\n                child.notifyLayoutReady(config);\n            }\n            else {\n                if (shouldCrossfade) {\n                    state.lead && child.pointTo(state.lead);\n                }\n                else {\n                    child.setVisibility(false);\n                }\n            }\n        },\n    };\n}\n\nexport { layoutStack };\n","import { __extends, __assign } from 'tslib';\nimport * as React from 'react';\nimport { Presence } from './types.js';\nimport { layoutStack } from './utils/stack.js';\nimport { SharedLayoutContext } from '../../context/SharedLayoutContext.js';\nimport { MotionContext } from '../../context/MotionContext/index.js';\nimport { resetRotate } from './utils/rotate.js';\nimport { createBatcher } from './utils/batcher.js';\n\n/**\n * @public\n */\nvar AnimateSharedLayout = /** @class */ (function (_super) {\n    __extends(AnimateSharedLayout, _super);\n    function AnimateSharedLayout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A list of all the children in the shared layout\n         */\n        _this.children = new Set();\n        /**\n         * As animate components with a defined `layoutId` are added/removed to the tree,\n         * we store them in order. When one is added, it will animate out from the\n         * previous one, and when it's removed, it'll animate to the previous one.\n         */\n        _this.stacks = new Map();\n        /**\n         * Track whether the component has mounted. If it hasn't, the presence of added children\n         * are set to Present, whereas if it has they're considered Entering\n         */\n        _this.hasMounted = false;\n        /**\n         * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n         * and schedule one.\n         */\n        _this.updateScheduled = false;\n        /**\n         * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n         */\n        _this.renderScheduled = false;\n        /**\n         * The methods provided to all children in the shared layout tree.\n         */\n        _this.syncContext = __assign(__assign({}, createBatcher()), { syncUpdate: function (force) { return _this.scheduleUpdate(force); }, forceUpdate: function () {\n                // By copying syncContext to itself, when this component re-renders it'll also re-render\n                // all children subscribed to the SharedLayout context.\n                _this.syncContext = __assign({}, _this.syncContext);\n                _this.scheduleUpdate(true);\n            }, register: function (child) { return _this.addChild(child); }, remove: function (child) { return _this.removeChild(child); } });\n        return _this;\n    }\n    AnimateSharedLayout.prototype.componentDidMount = function () {\n        this.hasMounted = true;\n    };\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\n        this.startLayoutAnimation();\n    };\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n        this.renderScheduled = true;\n        return true;\n    };\n    AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n        var _this = this;\n        /**\n         * Reset update and render scheduled status\n         */\n        this.renderScheduled = this.updateScheduled = false;\n        var type = this.props.type;\n        /**\n         * Update presence metadata based on the latest AnimatePresence status.\n         * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n         */\n        this.children.forEach(function (child) {\n            if (!child.isPresent) {\n                child.presence = Presence.Exiting;\n            }\n            else if (child.presence !== Presence.Entering) {\n                child.presence =\n                    child.presence === Presence.Exiting\n                        ? Presence.Entering\n                        : Presence.Present;\n            }\n        });\n        this.updateStacks();\n        /**\n         * Create a handler which we can use to flush the children animations\n         */\n        var handler = {\n            measureLayout: function (child) { return child.updateLayoutMeasurement(); },\n            layoutReady: function (child) {\n                if (child.getLayoutId() !== undefined) {\n                    var stack = _this.getStack(child);\n                    stack.animate(child, type === \"crossfade\");\n                }\n                else {\n                    child.notifyLayoutReady();\n                }\n            },\n            parent: this.context.visualElement,\n        };\n        /**\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n         * This requires some co-ordination across components to stop layout thrashing\n         * and ensure measurements are taken at the correct time.\n         *\n         * Here we use that same mechanism of schedule/flush.\n         */\n        this.children.forEach(function (child) { return _this.syncContext.add(child); });\n        this.syncContext.flush(handler);\n        /**\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n         */\n        this.stacks.forEach(function (stack) { return stack.clearSnapshot(); });\n    };\n    AnimateSharedLayout.prototype.updateStacks = function () {\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\n    };\n    AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n        if (force === void 0) { force = false; }\n        if (!(force || !this.updateScheduled))\n            return;\n        /**\n         * Flag we've scheduled an update\n         */\n        this.updateScheduled = true;\n        /**\n         * Write: Reset rotation transforms so bounding boxes can be accurately measured.\n         */\n        this.children.forEach(function (child) { return resetRotate(child); });\n        /**\n         * Read: Snapshot children\n         */\n        this.children.forEach(function (child) { return child.snapshotViewportBox(); });\n        /**\n         * Every child keeps a local snapshot, but we also want to record\n         * snapshots of the visible children as, if they're are being removed\n         * in this render, we can still access them.\n         *\n         * TODO: What would be better here is doing a single loop where we\n         * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n         */\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\n        /**\n         * Force a rerender by setting state if we aren't already going to render.\n         */\n        if (force || !this.renderScheduled) {\n            this.renderScheduled = true;\n            this.forceUpdate();\n        }\n    };\n    AnimateSharedLayout.prototype.addChild = function (child) {\n        this.children.add(child);\n        this.addToStack(child);\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n    };\n    AnimateSharedLayout.prototype.removeChild = function (child) {\n        this.scheduleUpdate();\n        this.children.delete(child);\n        this.removeFromStack(child);\n    };\n    AnimateSharedLayout.prototype.addToStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.add(child);\n    };\n    AnimateSharedLayout.prototype.removeFromStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.remove(child);\n    };\n    /**\n     * Return a stack of animate children based on the provided layoutId.\n     * Will create a stack if none currently exists with that layoutId.\n     */\n    AnimateSharedLayout.prototype.getStack = function (child) {\n        var id = child.getLayoutId();\n        if (id === undefined)\n            return;\n        // Create stack if it doesn't already exist\n        !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n        return this.stacks.get(id);\n    };\n    AnimateSharedLayout.prototype.render = function () {\n        return (React.createElement(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children));\n    };\n    AnimateSharedLayout.contextType = MotionContext;\n    return AnimateSharedLayout;\n}(React.Component));\n\nexport { AnimateSharedLayout };\n","import { transformAxes } from '../../../render/html/utils/transform.js';\n\nfunction resetRotate(child) {\n    // If there's no detected rotation values, we can early return without a forced render.\n    var hasRotate = false;\n    // Keep a record of all the values we've reset\n    var resetValues = {};\n    // Check the rotate value of all axes and reset to 0\n    for (var i = 0; i < transformAxes.length; i++) {\n        var axis = transformAxes[i];\n        var key = \"rotate\" + axis;\n        // If this rotation doesn't exist as a motion value, then we don't\n        // need to reset it\n        if (!child.hasValue(key) || child.getStaticValue(key) === 0)\n            continue;\n        hasRotate = true;\n        // Record the rotation and then temporarily set it to 0\n        resetValues[key] = child.getStaticValue(key);\n        child.setStaticValue(key, 0);\n    }\n    // If there's no rotation values, we don't need to do any more.\n    if (!hasRotate)\n        return;\n    // Force a render of this element to apply the transform with all rotations\n    // set to 0.\n    child.syncRender();\n    // Put back all the values we reset\n    for (var key in resetValues) {\n        child.setStaticValue(key, resetValues[key]);\n    }\n    // Schedule a render for the next frame. This ensures we won't visually\n    // see the element with the reset rotate value applied.\n    child.scheduleRender();\n}\n\nexport { resetRotate };\n","import * as React from 'react';\nimport { useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.js';\nimport { useConstant } from '../../utils/use-constant.js';\n\nvar presenceId = 0;\nfunction getPresenceId() {\n    var id = presenceId;\n    presenceId++;\n    return id;\n}\nvar PresenceChild = function (_a) {\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom, presenceAffectsLayout = _a.presenceAffectsLayout;\n    var presenceChildren = useConstant(newChildrenMap);\n    var id = useConstant(getPresenceId);\n    var context = useMemo(function () { return ({\n        id: id,\n        initial: initial,\n        isPresent: isPresent,\n        custom: custom,\n        onExitComplete: function (childId) {\n            presenceChildren.set(childId, true);\n            var allComplete = true;\n            presenceChildren.forEach(function (isComplete) {\n                if (!isComplete)\n                    allComplete = false;\n            });\n            allComplete && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n        },\n        register: function (childId) {\n            presenceChildren.set(childId, false);\n            return function () { return presenceChildren.delete(childId); };\n        },\n    }); }, \n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout ? undefined : [isPresent]);\n    useMemo(function () {\n        presenceChildren.forEach(function (_, key) { return presenceChildren.set(key, false); });\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(function () {\n        !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n    }, [isPresent]);\n    return (React.createElement(PresenceContext.Provider, { value: context }, children));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nexport { PresenceChild };\n","import { __spreadArray, __read } from 'tslib';\nimport * as React from 'react';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport { useForceUpdate } from '../../utils/use-force-update.js';\nimport { PresenceChild } from './PresenceChild.js';\nimport { SharedLayoutContext, isSharedLayout } from '../../context/SharedLayoutContext.js';\n\nfunction getChildKey(child) {\n    return child.key || \"\";\n}\nfunction updateChildLookup(children, allChildren) {\n    var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n    children.forEach(function (child) {\n        var key = getChildKey(child);\n        if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n            if (seenChildren.has(key)) {\n                console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n            }\n            seenChildren.add(key);\n        }\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    var filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, function (child) {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * @library\n *\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { Frame, AnimatePresence } from 'framer'\n *\n * // As items are added and removed from `items`\n * export function Items({ items }) {\n *   return (\n *     <AnimatePresence>\n *       {items.map(item => (\n *         <Frame\n *           key={item.id}\n *           initial={{ opacity: 0 }}\n *           animate={{ opacity: 1 }}\n *           exit={{ opacity: 0 }}\n *         />\n *       ))}\n *     </AnimatePresence>\n *   )\n * }\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * @motion\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function (_a) {\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    var forceRender = useForceUpdate();\n    var layoutContext = useContext(SharedLayoutContext);\n    if (isSharedLayout(layoutContext)) {\n        forceRender = layoutContext.forceUpdate;\n    }\n    var isInitialRender = useRef(true);\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    var filteredChildren = onlyElements(children);\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    var presentChildren = useRef(filteredChildren);\n    // A lookup table to quickly reference components by key\n    var allChildren = useRef(new Map())\n        .current;\n    // A living record of all currently exiting components.\n    var exiting = useRef(new Set()).current;\n    updateChildLookup(filteredChildren, allChildren);\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    if (isInitialRender.current) {\n        isInitialRender.current = false;\n        return (React.createElement(React.Fragment, null, filteredChildren.map(function (child) { return (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout }, child)); })));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    var childrenToRender = __spreadArray([], __read(filteredChildren));\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    var presentKeys = presentChildren.current.map(getChildKey);\n    var targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    var numPresent = presentKeys.length;\n    for (var i = 0; i < numPresent; i++) {\n        var key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n        else {\n            // In case this key has re-entered, remove from the exiting list\n            exiting.delete(key);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (exitBeforeEnter && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach(function (key) {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        var child = allChildren.get(key);\n        if (!child)\n            return;\n        var insertionIndex = presentKeys.indexOf(key);\n        var onExit = function () {\n            allChildren.delete(key);\n            exiting.delete(key);\n            // Remove this child from the present children\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, React.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map(function (child) {\n        var key = child.key;\n        return exiting.has(key) ? (child) : (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    presentChildren.current = childrenToRender;\n    if (process.env.NODE_ENV !== \"production\" &&\n        exitBeforeEnter &&\n        childrenToRender.length > 1) {\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n    }\n    return (React.createElement(React.Fragment, null, exiting.size\n        ? childrenToRender\n        : childrenToRender.map(function (child) { return cloneElement(child); })));\n};\n\nexport { AnimatePresence };\n","import { __read } from 'tslib';\nimport { useCallback, useRef, useState } from 'react';\nimport { useUnmountEffect } from './use-unmount-effect.js';\n\nfunction useForceUpdate() {\n    var unloadingRef = useRef(false);\n    var _a = __read(useState(0), 2), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\n    useUnmountEffect(function () { return (unloadingRef.current = true); });\n    return useCallback(function () {\n        !unloadingRef.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [forcedRenderCount]);\n}\n\nexport { useForceUpdate };\n"],"sourceRoot":""}